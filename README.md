# Timers

## Зміст
- [Завдання 1: Система нагадувань з використанням POSIX таймерів](#завдання-1-система-нагадувань-з-використанням-posix-таймерів)
- [Завдання 2: Демонстрація POSIX Інтервального Таймера](#завдання-2-демонстрація-posix-інтервального-таймера)
---

## Завдання 1: Система нагадувань з використанням POSIX таймерів

### Опис
Розроблено консольну програму "Система Нагадувань" на мові C, яка дозволяє користувачеві інтерактивно встановлювати одноразові та багаторазові (періодичні) нагадування з різними часовими інтервалами. Коли настає час для нагадування, програма виводить відповідне повідомлення, вказане користувачем. Система базується на POSIX таймерах для точного керування часом спрацювання подій та використовує техніку "self-pipe" для безпечної та надійної обробки сигналів від таймерів в основному циклі програми. Програма також підтримує коректне завершення роботи та звільнення ресурсів за командою користувача або через сигнал `SIGINT` (Ctrl+C).

### Ключові технології та механізми:
- **POSIX Таймери:** Використання функцій `timer_create()`, `timer_settime()` та `timer_delete()` для створення, налаштування та видалення індивідуальних таймерів для кожного нагадування. Використовується `CLOCK_REALTIME`.
- **Обробка сигналів:** Налаштування обробників сигналів за допомогою `sigaction()`. Прапорець `SA_SIGINFO` використовується для передачі додаткової інформації в обробник (зокрема, унікального ідентифікатора нагадування через `sigev_value.sival_ptr`). Сигнал `SIGRTMIN` обрано для сповіщень від таймерів, `SIGINT` – для перехоплення запиту на завершення програми.
- **Техніка "Self-pipe":** Створення неблокуючого pipe (`pipe()`, `fcntl(O_NONBLOCK)`), куди обробник сигналу записує мінімальну інформацію (UID нагадування). Основний цикл програми використовує `select()` для моніторингу цього pipe (та стандартного вводу), що дозволяє безпечно обробляти події від таймерів поза контекстом обробника сигналу.
- **Динамічне керування пам'яттю:** Використання `realloc()` для динамічного масиву, що зберігає структури активних нагадувань.
- **Обробка вводу користувача:** Зчитування команд користувача (`add`, `exit`) за допомогою `fgets()` та їх парсинг за допомогою `sscanf()`.
- **Робота з часом:** Використання `struct timespec` для налаштування таймерів, а також `time_t`, `localtime()`, `strftime()` для форматування та виведення поточного часу у повідомленнях нагадувань.

### Результати
```
Система Нагадувань (PID: 1513) запущена.
Введіть 'add <затримка_сек> <інтервал_сек> <повідомлення>' для додавання нагадування (<інтервал_сек> = 0 для одноразового нагадування)
Введіть 'exit' або натисніть Ctrl+C для виходу.
>add 4 15 task12-13 is done!
REMINDER_SYS: Нагадування ID 1 додано: 'task12-13 is done!' через 4с, повтор кожні 15с.
>>
[2025-06-02 18:13:28] НАГАДУВАННЯ (ID 1): task12-13 is done!
>>
[2025-06-02 18:13:43] НАГАДУВАННЯ (ID 1): task12-13 is done!
>add 3 0 task14 is done!
REMINDER_SYS: Нагадування ID 2 додано: 'task14 is done!' через 3с, повтор кожні 0с.
>>
[2025-06-02 18:13:58] НАГАДУВАННЯ (ID 1): task12-13 is done!
>>
[2025-06-02 18:13:58] НАГАДУВАННЯ (ID 2): task14 is done!
(Одноразове нагадування ID 2 виконано.)
>exit
REMINDER_SYS: Починаю процедуру завершення...
Видаляю таймер для нагадування ID 1...
REMINDER_SYS: Програму завершено.
```

### Пояснення
- **Ініціалізація:** При запуску програма виводить вітальне повідомлення з інструкціями щодо використання. Створюється внутрішній канал (self-pipe) для комунікації між обробником сигналів та основним циклом. Встановлюються обробники для сигналу `TIMER_SIGNAL` (визначеного як `SIGRTMIN`), який буде використовуватися POSIX-таймерами, та для сигналу `SIGINT` (для перехоплення Ctrl+C).
- **Додавання нагадувань (команда `add`):**
    - Користувач вводить команду у форматі `add <затримка_сек> <інтервал_сек> <повідомлення>`.
    - Програма розбирає введені параметри.
    - Для кожного нового нагадування створюється POSIX-таймер за допомогою `timer_create()`. Важливо, що при створенні таймера через структуру `sigevent` (поле `sigev_value.sival_ptr`) йому передається унікальний ідентифікатор нагадування (`reminder_uid`). Це дозволяє обробнику сигналу точно визначити, який саме таймер спрацював.
    - Час спрацювання таймера налаштовується за допомогою `timer_settime()`. Поле `it_value` встановлює час до першого спрацювання (вказана користувачем затримка), а `it_interval` – період для повторних спрацювань. Якщо `it_interval` дорівнює нулю, таймер є одноразовим.
    - Уся інформація про нагадування (включаючи ID створеного таймера, текст повідомлення, UID та параметри інтервалу) зберігається у динамічному масиві структур `Reminder`.
- **Обробка спрацювання таймера:**
    - Коли POSIX-таймер спрацьовує, він надсилає процесу визначений сигнал (`TIMER_SIGNAL`).
    - Спрацьовує встановлений обробник сигналу (`timer_event_signal_handler`). Завдяки прапорцю `SA_SIGINFO`, обробник отримує доступ до структури `siginfo_t`, з якої витягує `reminder_uid`.
    - Обробник записує цей `reminder_uid` у write-кінець self-pipe.
    - Основний цикл програми використовує `select()` для одночасного моніторингу стандартного вводу (команди користувача) та read-кінця self-pipe. Коли `select()` виявляє активність на pipe, це означає, що спрацював один із таймерів.
    - Основний цикл читає `reminder_uid` з pipe. На основі цього UID він знаходить відповідне нагадування у своєму списку, виводить повідомлення користувача разом із поточною датою та часом.
- **Обробка команд користувача та завершення:**
    - Якщо `select()` виявляє активність на стандартному вводі, програма читає введену команду. Підтримуються команди `add` (описано вище) та `exit` (або `quit`).
    - При отриманні команди `exit` або сигналу `SIGINT` (Ctrl+C), встановлюється прапорець `shutdown_requested_flag`.
    - Основний цикл завершує свою роботу. Перед повним виходом програма проходить по всіх активних нагадуваннях, видаляє відповідні POSIX-таймери (`timer_delete()`), звільняє динамічно виділену пам'ять для списку нагадувань та закриває файлові дескриптори self-pipe.

### Висновки
- Програма демонструє створення та керування системою нагадувань, що підтримує як одноразові, так і багаторазові події з індивідуально налаштовуваними інтервалами, використовуючи POSIX-таймери.
- Застосування техніки "self-pipe" у поєднанні з `select()` дозволяє надійно та безпечно обробляти асинхронні сигнали від таймерів, відокремлюючи логіку негайної реакції на сигнал (в обробнику) від основної логіки обробки події (в головному циклі).

The provided code correctly demonstrates a basic POSIX interval timer that sends `SIGRTMIN` every second, which is then caught by the signal handler to print "Tick". The code generally doesn't require corrections for its stated purpose, but error checking for system calls should always be added for robust programs.

## Завдання 2: Демонстрація POSIX Інтервального Таймера

### Опис
Ця програма демонструє створення та використання POSIX інтервального таймера. Таймер налаштований на спрацювання щосекунди. При кожному спрацюванні таймер генерує сигнал `SIGRTMIN`, який перехоплюється встановленим обробником сигналу. Обробник сигналу виводить повідомлення "Tick" на стандартний вивід. Програма продовжує працювати та отримувати "тіки" від таймера, доки не буде примусово завершена.

### Ключові технології та механізми:
* **POSIX Таймери:** Використовуються функції `timer_create()` для створення таймера, `timer_settime()` для його налаштування та запуску. Обрано `CLOCK_REALTIME`.
* **Обробка сигналів:** Використовується `sigaction()` для встановлення обробника сигналу. Прапорець `SA_SIGINFO` дозволяє використовувати поле `sa_sigaction` для обробника, який може отримувати додаткову інформацію про сигнал.
* **Сигнали реального часу:** Використовується `SIGRTMIN` як сигнал, що генерується таймером. Це допомагає уникнути конфліктів зі стандартними сигналами UNIX.
* **Сповіщення про подію таймера:** Таймер налаштований на сповіщення через сигнал (`sev.sigev_notify = SIGEV_SIGNAL`).
* **Інтервальний таймер:** Структура `itimerspec` використовується для встановлення початкового часу спрацювання (`it_value`) та інтервалу повторення (`it_interval`). В даному випадку обидва встановлені на 1 секунду, що робить таймер періодичним.
* **Очікування сигналів:** Основний цикл програми використовує `pause()`, що призупиняє виконання процесу до отримання будь-якого сигналу, для якого встановлено обробник або дія за замовчуванням якого – завершення процесу.

### Результати (Очікуваний вивід)
При запуску програми, консоль буде виводити "Tick" кожну секунду:
```
Програма запущена. Очікування сигналів таймера (SIGRTMIN). Натисніть Ctrl+C для виходу.
Tick
Tick
Tick
... (і так далі, доки програма не буде перервана, наприклад, через Ctrl+C)
```

### Пояснення
1.  **Налаштування обробника сигналу (`sigaction`)**:
    * `sa.sa_flags = SA_SIGINFO;` вказує, що ми хочемо використовувати поле `sa_sigaction` для обробника, яке приймає три аргументи (`int`, `siginfo_t*`, `void*`), надаючи більше інформації про сигнал.
    * `sa.sa_sigaction = handler;` встановлює нашу функцію `handler` як обробник.
    * `sigaction(SIGRTMIN, &sa, NULL);` реєструє обробник для сигналу `SIGRTMIN`.

2.  **Створення таймера (`timer_create`)**:
    * `sev.sigev_notify = SIGEV_SIGNAL;` визначає, що при спрацюванні таймера буде надіслано сигнал.
    * `sev.sigev_signo = SIGRTMIN;` вказує, що буде надіслано саме сигнал `SIGRTMIN`.
    * `sev.sigev_value.sival_ptr = &timerid;` (опціонально) дозволяє передати дані разом із сигналом. У цьому прикладі `handler` не використовує ці дані, але це стандартний спосіб зв'язати подію таймера з конкретним таймером або даними.
    * `timer_create(CLOCK_REALTIME, &sev, &timerid);` створює таймер, використовуючи системний годинник реального часу. `timerid` зберігає ідентифікатор створеного таймера.

3.  **Налаштування та запуск таймера (`timer_settime`)**:
    * `its.it_value.tv_sec = 1;` встановлює початкову затримку до першого спрацювання таймера на 1 секунду.
    * `its.it_interval.tv_sec = 1;` встановлює інтервал для наступних спрацювань також на 1 секунду. Якщо `it_interval` був би нульовим, таймер спрацював би лише один раз.
    * `timer_settime(timerid, 0, &its, NULL);` активує таймер з вказаними налаштуваннями. Другий аргумент `0` означає, що час `it_value` є відносним (від поточного моменту).

4.  **Обробник сигналу (`handler`)**:
    * Коли таймер спрацьовує, система надсилає сигнал `SIGRTMIN` процесу.
    * Викликається функція `handler`.
    * `write(STDOUT_FILENO, "Tick\n", 5);` виводить повідомлення "Tick" на стандартний вивід. `write` є асинхронно-безпечною функцією, тому її можна безпечно використовувати в обробниках сигналів.

5.  **Основний цикл (`while(1) pause();`)**:
    * `pause()` призупиняє виконання процесу до отримання сигналу, для якого встановлено обробник, або який завершує процес. У нашому випадку, `pause()` буде перериватися сигналом `SIGRTMIN` від таймера, після чого виконається обробник, і `pause()` буде викликано знову.

### Висновки
- Програма успішно демонструє створення періодичного POSIX таймера, який генерує сигнали реального часу (`SIGRTMIN`).
- Використання `sigaction` з `SA_SIGINFO` для налаштування обробника є сучасним підходом до обробки сигналів.
- `pause()` є простим способом очікування сигналів в однопотоковій програмі, яка переважно керується сигналами.
- Додана базова перевірка помилок для системних викликів підвищує надійність програми. Для завершення роботи програми в поточній реалізації необхідно використовувати зовнішній сигнал, наприклад, `SIGINT` (Ctrl+C), для якого можна було б також встановити обробник для коректного видалення таймера за допомогою `timer_delete(timerid);`.
