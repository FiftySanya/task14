# Timers

## Зміст
- [Завдання 1: Система нагадувань з використанням POSIX таймерів](#завдання-1-система-нагадувань-з-використанням-posix-таймерів)

---

## Завдання 1: Система нагадувань з використанням POSIX таймерів

### Опис
Розроблено консольну програму "Система Нагадувань" на мові C, яка дозволяє користувачеві інтерактивно встановлювати одноразові та багаторазові (періодичні) нагадування з різними часовими інтервалами. Коли настає час для нагадування, програма виводить відповідне повідомлення, вказане користувачем. Система базується на POSIX таймерах для точного керування часом спрацювання подій та використовує техніку "self-pipe" для безпечної та надійної обробки сигналів від таймерів в основному циклі програми. Програма також підтримує коректне завершення роботи та звільнення ресурсів за командою користувача або через сигнал `SIGINT` (Ctrl+C).

### Ключові технології та механізми:
- **POSIX Таймери:** Використання функцій `timer_create()`, `timer_settime()` та `timer_delete()` для створення, налаштування та видалення індивідуальних таймерів для кожного нагадування. Використовується `CLOCK_REALTIME`.
- **Обробка сигналів:** Налаштування обробників сигналів за допомогою `sigaction()`. Прапорець `SA_SIGINFO` використовується для передачі додаткової інформації в обробник (зокрема, унікального ідентифікатора нагадування через `sigev_value.sival_ptr`). Сигнал `SIGRTMIN` обрано для сповіщень від таймерів, `SIGINT` – для перехоплення запиту на завершення програми.
- **Техніка "Self-pipe":** Створення неблокуючого pipe (`pipe()`, `fcntl(O_NONBLOCK)`), куди обробник сигналу записує мінімальну інформацію (UID нагадування). Основний цикл програми використовує `select()` для моніторингу цього pipe (та стандартного вводу), що дозволяє безпечно обробляти події від таймерів поза контекстом обробника сигналу.
- **Динамічне керування пам'яттю:** Використання `realloc()` для динамічного масиву, що зберігає структури активних нагадувань.
- **Обробка вводу користувача:** Зчитування команд користувача (`add`, `exit`) за допомогою `fgets()` та їх парсинг за допомогою `sscanf()`.
- **Робота з часом:** Використання `struct timespec` для налаштування таймерів, а також `time_t`, `localtime()`, `strftime()` для форматування та виведення поточного часу у повідомленнях нагадувань.

### Результати
```
Система Нагадувань (PID: 1513) запущена.
Введіть 'add <затримка_сек> <інтервал_сек> <повідомлення>' для додавання нагадування (<інтервал_сек> = 0 для одноразового нагадування)
Введіть 'exit' або натисніть Ctrl+C для виходу.
>add 4 15 task12-13 is done!
REMINDER_SYS: Нагадування ID 1 додано: 'task12-13 is done!' через 4с, повтор кожні 15с.
>>
[2025-06-02 18:13:28] НАГАДУВАННЯ (ID 1): task12-13 is done!
>>
[2025-06-02 18:13:43] НАГАДУВАННЯ (ID 1): task12-13 is done!
>add 3 0 task14 is done!
REMINDER_SYS: Нагадування ID 2 додано: 'task14 is done!' через 3с, повтор кожні 0с.
>>
[2025-06-02 18:13:58] НАГАДУВАННЯ (ID 1): task12-13 is done!
>>
[2025-06-02 18:13:58] НАГАДУВАННЯ (ID 2): task14 is done!
(Одноразове нагадування ID 2 виконано.)
>exit
REMINDER_SYS: Починаю процедуру завершення...
Видаляю таймер для нагадування ID 1...
REMINDER_SYS: Програму завершено.
```

### Пояснення
- **Ініціалізація:** При запуску програма виводить вітальне повідомлення з інструкціями щодо використання. Створюється внутрішній канал (self-pipe) для комунікації між обробником сигналів та основним циклом. Встановлюються обробники для сигналу `TIMER_SIGNAL` (визначеного як `SIGRTMIN`), який буде використовуватися POSIX-таймерами, та для сигналу `SIGINT` (для перехоплення Ctrl+C).
- **Додавання нагадувань (команда `add`):**
    - Користувач вводить команду у форматі `add <затримка_сек> <інтервал_сек> <повідомлення>`.
    - Програма розбирає введені параметри.
    - Для кожного нового нагадування створюється POSIX-таймер за допомогою `timer_create()`. Важливо, що при створенні таймера через структуру `sigevent` (поле `sigev_value.sival_ptr`) йому передається унікальний ідентифікатор нагадування (`reminder_uid`). Це дозволяє обробнику сигналу точно визначити, який саме таймер спрацював.
    - Час спрацювання таймера налаштовується за допомогою `timer_settime()`. Поле `it_value` встановлює час до першого спрацювання (вказана користувачем затримка), а `it_interval` – період для повторних спрацювань. Якщо `it_interval` дорівнює нулю, таймер є одноразовим.
    - Уся інформація про нагадування (включаючи ID створеного таймера, текст повідомлення, UID та параметри інтервалу) зберігається у динамічному масиві структур `Reminder`.
- **Обробка спрацювання таймера:**
    - Коли POSIX-таймер спрацьовує, він надсилає процесу визначений сигнал (`TIMER_SIGNAL`).
    - Спрацьовує встановлений обробник сигналу (`timer_event_signal_handler`). Завдяки прапорцю `SA_SIGINFO`, обробник отримує доступ до структури `siginfo_t`, з якої витягує `reminder_uid`.
    - Обробник записує цей `reminder_uid` у write-кінець self-pipe.
    - Основний цикл програми використовує `select()` для одночасного моніторингу стандартного вводу (команди користувача) та read-кінця self-pipe. Коли `select()` виявляє активність на pipe, це означає, що спрацював один із таймерів.
    - Основний цикл читає `reminder_uid` з pipe. На основі цього UID він знаходить відповідне нагадування у своєму списку, виводить повідомлення користувача разом із поточною датою та часом.
- **Обробка команд користувача та завершення:**
    - Якщо `select()` виявляє активність на стандартному вводі, програма читає введену команду. Підтримуються команди `add` (описано вище) та `exit` (або `quit`).
    - При отриманні команди `exit` або сигналу `SIGINT` (Ctrl+C), встановлюється прапорець `shutdown_requested_flag`.
    - Основний цикл завершує свою роботу. Перед повним виходом програма проходить по всіх активних нагадуваннях, видаляє відповідні POSIX-таймери (`timer_delete()`), звільняє динамічно виділену пам'ять для списку нагадувань та закриває файлові дескриптори self-pipe.

### Висновки
- Програма демонструє створення та керування системою нагадувань, що підтримує як одноразові, так і багаторазові події з індивідуально налаштовуваними інтервалами, використовуючи POSIX-таймери.
- Застосування техніки "self-pipe" у поєднанні з `select()` дозволяє надійно та безпечно обробляти асинхронні сигнали від таймерів, відокремлюючи логіку негайної реакції на сигнал (в обробнику) від основної логіки обробки події (в головному циклі).
